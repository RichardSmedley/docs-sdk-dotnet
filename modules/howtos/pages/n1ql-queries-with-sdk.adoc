= N1QL Queries from the SDK
:navtitle: N1QL from the SDK
:page-topic-type: howto
:page-aliases: n1ql-query

[abstract]
You can query for documents in Couchbase using the N1QL query language, a language based on SQL, but designed for structured and flexible JSON documents.
Querying can solve typical programming tasks such as finding a user profile by email address, facebook login, or user ID.



Our query service uses N1QL, which will be fairly familiar to anyone who's used any dialect of SQL.
xref:#additional-resources[Further resources] for learning about N1QL are listed at the bottom of the page.
Before you get started you may wish to checkout the xref:server:n1ql:n1ql-language-reference/index.adoc[N1QL intro page], or just dive in with a query against xref:server:manage:manage-settings/install-sample-buckets.adoc[our travel sample data set].
In this case, the one thing that you need to know is that in order to make a Bucket queryable, it must have at least one index defined.
You can define a _primary_ index on a bucket. When executing queries, if a suitable index is not found, the primary index will ensure that the query will be executed anyway (the primary index should be not be used in production to prevent scanning of the whole bucket).

To execute N1QL, you can use xref:server:tools:query-workbench.adoc[Query Workbench] (or you can use the xref:server:tools:cbq-shell.adoc[cbq command line tool]).
Open it, and enter the following:

[source,n1ql]
----
CREATE PRIMARY INDEX ON `travel-sample`
----

or replace _travel-sample_ with a different Bucket name to build an index on a different Bucket.

NOTE: If you are using _travel-sample_, it comes with a primary index already created.


== Parameterization

Parameters allow you to specify variable constraints for an otherwise constant query. Parameterization is also a good defense against SQL injection.
There are two variants of parameters: positional and named.
Positional parameters use a numbered placeholder for substitution and named parameters use a named placeholder.
A named or positional parameter can be used in the WHERE, LIMIT or OFFSET clauses of a query.

.Positional parameter example:
[source,csharp,indent=0]
----
include::example$/n1ql-queries-sdk/n1ql-queries-sdk/Program.cs[tag=positional]
----

.Named parameter example:
[source,csharp,indent=0]
----
include::example$/n1ql-queries-sdk/n1ql-queries-sdk/Program.cs[tag=namedparameter]
----

== Handling Results

In most cases your query will return more than one result, and you may be looking to iterate over those results:

[source,csharp,indent=0]
----
include::example$/n1ql-queries-sdk/n1ql-queries-sdk/Program.cs[tag=namedparameter]

include::example$/n1ql-queries-sdk/n1ql-queries-sdk/Program.cs[tag=namedparameter2]
----

== Scan Consistency

Setting a staleness parameter for queries, with `scan_consistency`, enables a tradeoff between latency and (eventual) consistency.

* A N1QL query using the default *Not Bounded* Scan Consistency will not wait for any indexes to finish updating before running the query and returning results, meaning that results are returned quickly, but the query will not return any documents that are yet to be indexed.

.ScanConsitency (NotBounded)
[source,csharp,indent=0]
----
include::example$/n1ql-queries-sdk/n1ql-queries-sdk/Program.cs[tag=notbounded]
----

* With Scan Consistency set to *RequestPlus*, all document changes and index updates are processed before the query is run.
Select this when consistency is always more important than performance.

.ScanConsitency (RequestPlus)
[source,csharp,indent=0]
----
include::example$/n1ql-queries-sdk/n1ql-queries-sdk/Program.cs[tag=requestplus]
----

* For a middle ground, *AtPlus* is a "read your own write" (RYOW) option, which means it just waits for the new documents that you specify to be indexed, rather than an entire index of multiple documents.

.ScanConsistency (AtPlus/RYOW example)
[source,csharp,indent=0]
----
include::example$/n1ql-queries-sdk/n1ql-queries-sdk/Program.cs[tag=atplus]
----

== Streaming Large Result Sets

By default the .NET SDK will stream the result set from the server, where the client will start a persistent connection with the server and only read the header until the Rows are enumerated; then, each row or JSON object will be de-serialized one at a time.

This decreases pressure on CLR Garbage Collection and helps to prevent an `OutOfMemoryException` being thrown.

== Additional Resources

NOTE: N1QL is not the only query option in Couchbase.
Be sure to check that xref:concept-docs:data-services.adoc[your use case fits your selection of query service].

* For a deeper dive into N1QL from the SDK, refer to our xref:concept-docs:n1ql-query.adoc[N1QL SDK concept doc].
* The xref:6.5@server:n1ql:n1ql-language-reference/index.adoc[Server doc N1QL intro] introduces a complete guide to the N1QL language, including all of the latest additions.
* The http://query.pub.couchbase.com/tutorial/#1[N1QL interactive tutorial] is a good introduction to the basics of N1QL use.
* For scaling up queries, be sure to xref:server:learn:services-and-indexes:indexes:index-replication.adoc[read up on Indexes].
* N1QL is for operational queries; for analytical workloads, read more on xref:concept-docs:http-services.adoc#Long-Running-Queries-&-Big-Data[when to choose Analytics], our implementation of SQL++ available in the Enterprise Edition.

